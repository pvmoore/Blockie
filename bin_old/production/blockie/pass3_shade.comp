#version 430 core
layout(local_size_x = 8, local_size_y = 8) in;

#include "header.inc"

layout(binding = 0, std430) readonly buffer I0 {
	MarchOut dataIn[];
};

// vec4(vec3 pos, float voxel)
//layout(binding = 0, rgba32f)
//uniform readonly image2D imageIn;

layout(binding = 1, rgba8)
uniform writeonly image2D imageOut;

//layout(binding = 2, rgba8)
//uniform readonly image2D material0;

layout(binding=3)
uniform sampler2D SAMPLER0;


uniform ivec2 SIZE;         // Render window size
uniform vec3 SUN_POS;       // in worldcoords
uniform vec3 CAMERA_POS;    // in worldcoords
uniform vec3  SCREEN_MIDDLE;    // for calculating Ray
uniform vec3  SCREEN_XDELTA;    // for calculating Ray
uniform vec3  SCREEN_YDELTA;    // for calculating Ray

ivec2 pixel  = ivec2(gl_GlobalInvocationID.xy);
//ivec2 l_pos  = ivec2(gl_LocalInvocationID.xy);
uint g_index = gl_GlobalInvocationID.x +
               gl_GlobalInvocationID.y*SIZE.x;
//uint l_index = gl_LocalInvocationIndex;

#include "useful_functions.comp"
//#include "perlin_noise.comp"
#include "simplex_noise_3d.comp"
#include "camera.inc"

#line 1
#define V_EARTH1 (10)
#define V_ROCK1 (11)
#define V_GRASS1 (12)

/// Calculate the hit pos given a screen pixel
vec3 getHitPos(ivec2 pos) {
    uint i     = pos.x + (pos.y*SIZE.x);
    vec3 dir   = getRayDirForPixel(pos);
    float dist = dataIn[i].distance;
    return CAMERA_POS + (dir*dist);
}

const vec3 uint_to_pixel[] = vec3[](
    // volumetric
	vec3(0,0, 0.25),	 // [0] V_AIR (space)
	vec3(0.156863,0.290196,0.341176),         // [1] water
    vec3(0.7,0.7,0.7),   // [2] smoke
    // reserved
    vec3(0,0,0),         // [3] reserved
    vec3(0,0,0),         // [4] reserved
    vec3(0,0,0),         // [5] reserved
    vec3(0,0,0),         // [6] reserved
    vec3(0,0,0),         // [7] reserved
    vec3(0,0,0),         // [8] reserved
    vec3(0,0,0),         // [9] reserved

    // single voxels
    vec3(0.5059, 0.3686, 0.2627)*0.7,	// [10] V_EARTH1
    vec3(0.352, 0.367, 0.363),          // [11] V_ROCK1
    vec3(0.2, 0.7,  0.2),	            // [12] V_GRASS1
    vec3(1.0, 1.0,  1.0),               // [13] V_SNOW
    vec3(1.0, 0.8,  0.5)                // [14] V_SAND
);

vec3 getDiffuse(uint voxel) {
    return uint_to_pixel[voxel];
}

vec3 calculateNormal(vec3 pos) {
    ivec2 i = pixel;
    ivec2 U = i+ivec2(0,-1);
    ivec2 L = i+ivec2(-1,0);
    ivec2 R = i+ivec2(1,0);
    ivec2 D = i+ivec2(0,1);

    const vec3 up    = getHitPos(U);
    const vec3 left  = getHitPos(L);
    const vec3 right = getHitPos(R);
    const vec3 down  = getHitPos(D);

    const vec3 n1 = cross(normalize(up-pos), normalize(left-pos));
    const vec3 n2 = cross(normalize(down-pos), normalize(right-pos));

    return normalize(n1+n2);
}
float getBrightness(const vec3 hitPos, const vec3 normal) {
    const vec3 lightPos = SUN_POS;
    const vec3 toLight  = normalize(lightPos-hitPos);
    const float NdotL      = dot(normal, toLight);
    return max(NdotL, 0);
}
vec3 getDiffuseColour(const uint voxel) {
    return getDiffuse(voxel);
}
//vec4 getDiffuseColour(const vec3 hitPos, const uint voxel) {
//    const vec3 lightPos = SUN_POS;
//    const vec3 normal   = calculateNormal();
//    const vec3 toLight  = normalize(lightPos-hitPos);
//
//    const float NdotL      = dot(normal, toLight);
//    const float brightness = max(NdotL, 0);
//
//    vec3 pixel = getDiffuse(voxel);
//
//    return vec4((pixel*0.70f) + (pixel*0.30f * brightness), 1);
//}
vec3 applyFog(vec3  rgb,      // original color of the pixel
              float distance) // camera to point distance
{
    const float density = 0.00015;
    const float fogAmount = 1.0 - exp( -distance*density );
    const vec3  fogColor  = vec3(0.5,0.6,0.7);
    return mix(rgb, fogColor, fogAmount);
}
vec3 applyFogWithSunScattering(
    vec3  rgb,      // original color of the pixel
    float distance, // camera to point distance
    vec3  rayDir,   // camera to point vector
    vec3  sunDir)   // sun light direction
{
    const float density = 0.00015;
    float fogAmount = 1.0 - exp( -distance*density );
    float sunAmount = max( dot( rayDir, sunDir ), 0.0);
    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish
                           vec3(1.0,0.9,0.7), // yellowish
                           pow(sunAmount,8.0) );
    return mix( rgb, fogColor, fogAmount );
}
vec3 applyGroundFog(
    vec3  rgb,      // original color of the pixel
    float distance, // camera to point distance
    vec3  rayOri,   // camera position
    vec3  rayDir)   // camera to point vector
{
    const float b = 0.0001;
    const float c = 1;
    const float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;
    const vec3  fogColor  = vec3(0.5,0.6,0.7);
    return mix( rgb, fogColor, fogAmount );
}
void main() {
    uint voxelInfo = dataIn[g_index].voxel;
    uint voxelSize = (voxelInfo>>8)&0xffu;
    uint voxel     = voxelInfo&0xffu;

    if(voxel==0) {
        imageStore(imageOut, pixel, vec4(0,0,0,0));
        return;
    }

    float dist  = dataIn[g_index].distance;
    vec3 hitPos = getHitPos(pixel);
    vec3 normal = calculateNormal(hitPos);

    vec3 diffuse = getDiffuseColour(voxel);

    if(true) {//} || voxel==V_ROCK1 || voxel==V_GRASS1 || voxel==V_EARTH1) {
        vec4 t  = texture(SAMPLER0, (hitPos.xz+hitPos.y)/100);
        diffuse.xyz = diffuse.xyz*0.25 + t.xyz;
    }

    // diffuse lighting
    diffuse = mix(diffuse*0.25, diffuse, getBrightness(hitPos, normal));

    // noise
    diffuse += clamp(40/(dist+0.1), 0.0, 0.2)*snoise(hitPos*5);

    #define FOG 1
    #if FOG
    vec3 rayDir = normalize(hitPos-CAMERA_POS);
    vec3 sunDir = normalize(SUN_POS-CAMERA_POS);
    //const vec4 colour = vec4(applyFog(diffuse.rgb, dist), diffuse.a);
    //const vec4 colour = vec4(applyFogWithSunScattering(diffuse.rgb, dist, rayDir, sunDir), diffuse.a);
    const vec4 colour = vec4(applyGroundFog(diffuse.rgb, dist, CAMERA_POS, rayDir), 1);
    #else
    // blend diffuse and sky based on distance from camera
    float fade = clamp(exp(8*(dist/15000)) / 120, 0.0, 1.0);
    vec3 sky   = vec3(0.345098,0.466667,0.560784);
    const vec4 colour = vec4(mix(diffuse.rgb, sky, fade), 1);
    #endif

    imageStore(imageOut, pixel, colour);
}
