
#line 1 5

uint getImpliedIndex_8bit(const uint bits, const uint oct) {
    const uint and = 0x7f >> (7-oct);
    return bitCount(bits & and);
}
uint getImpliedIndex_16bit(const uint bits, const uint oct) {
    const uint and = 0x7fff >> (15-oct);
    return bitCount(bits & and);
}
bool isSolidRoot(
    const uvec3 upos,
    const uint branchesOffset,
    inout uint voxelsPtr,
    inout Voxel v)
{
#if OCTREE_ROOT_BITS==2
    const uint oct = getOctetRoot_11(upos);
    const uint BB  = 8;     // 8 bytes for bits
#elif OCTREE_ROOT_BITS==3
    const uint oct = getOctetRoot_111(upos);
    const uint BB  = 64;    // 64 bytes for bits
#elif OCTREE_ROOT_BITS==4
    const uint oct = getOctetRoot_1111(upos);
    const uint BB  = 512;    // 512 bytes for bits
#endif

    const uint BITS_OFFSET = 4 + 6*4; // octree flag + offset bytes

    const uint uintIndex = (voxelsPtr+BITS_OFFSET)/4 + (oct>>4);
    const uint bitIndex  = oct&15u;
    const uint data      = voxelsIn[uintIndex];
    const uint bits      = data & 0xffffu;

    const bool solid     = !bool(bitfieldExtract(bits, int(bitIndex), 1));

    if(solid) {
        const uint voxelPtr = voxelsPtr+BITS_OFFSET+BB+BB+oct;
        v.size  = NIBBLE_SIZE;
        v.value = GETBYTE(voxelsIn, voxelPtr);
        v.oct   = oct;
    } else {
        const uint popcnt = data >> 16;
        voxelsPtr = branchesOffset +
                    (getImpliedIndex_16bit(bits, bitIndex)+popcnt) * OctreeTwigSize;
    }
    return solid;
}
bool isSolidBranch(
    const float distance,
    const uvec3 upos,
    const uint branchesOffset,
    inout uint voxelsPtr,
    inout Voxel v,
    const uint SZ)
{
    const uint oct   = getOctet_1_n(upos, SZ);
    const uint data  = voxelsIn[voxelsPtr/4];
    const bool solid =
        //distance>(SZ*500) ||
        !bool(bitfieldExtract(data, int(oct), 1));

    if(solid) {
        const uint voxelPtr = voxelsPtr+1+3+oct;
        v.size  = SZ;
        v.value = GETBYTE(voxelsIn, voxelPtr);
    } else {
        const uint bits = data & 0xffu;
        voxelsPtr = branchesOffset +
                    ((data>>8) + getImpliedIndex_8bit(bits, oct)) * OctreeTwigSize;
    }
    return solid;
}
bool isSolidBranchLevel3(
    const float distance,
    const uvec3 upos,
    const uint bitCounts,
    const uint l2IndexOffset,
    const uint l2TwigsOffset,
    inout uint voxelsPtr,
    inout Voxel v)
{
    const uint oct   = getOctet_1_3(upos);
    const uint data  = voxelsIn[voxelsPtr/4];
    const bool solid =
        //distance>3000 ||
        !bool(bitfieldExtract(data, int(oct), 1));

    if(solid) {
        const uint voxelPtr = voxelsPtr+1+3+oct;
        v.size  = 4;
        v.value = GETBYTE(voxelsIn, voxelPtr);
    } else {
        const uint bits      = data & 0xffu;
        const uint numIndexBits = (bitCounts >> 8) & 0xffu;
        const uint bitOffset = ((data>>8) + getImpliedIndex_8bit(bits, oct)) * numIndexBits;
        const uint index     = getBits_voxelsIn(l2IndexOffset, bitOffset, int(numIndexBits));

        voxelsPtr = l2TwigsOffset + index * OctreeTwigSize;
    }
    return solid;
}
bool isSolidBranchLevel2(
    const float distance,
    const uvec3 upos,
    const uint bitCounts,
    const uint leafIndexOffset,
    const uint leavesOffset,
    inout uint voxelsPtr,
    inout Voxel v)
{
    const uint oct   = getOctet_1_2(upos);
    const uint data  = voxelsIn[voxelsPtr/4];
    const bool solid =
        //distance>2000 ||
        !bool(bitfieldExtract(data, int(oct), 1));

    if(solid) {
        const uint voxelPtr = voxelsPtr+1+3+oct;
        v.size  = 2;
        v.value = GETBYTE(voxelsIn, voxelPtr);
    } else {
        const uint bits  = data & 0xffu;
        const uint numIndexBits = bitCounts & 0xffu;
        const uint bitOffset = ((data>>8) + getImpliedIndex_8bit(bits, oct)) * numIndexBits;
        const uint leafIndex = getBits_voxelsIn(leafIndexOffset, bitOffset, int(numIndexBits));

        voxelsPtr = leavesOffset + leafIndex * OctreeLeafSize;
    }
    return solid;
}
void gavLeaf(const uvec3 upos,
             const uint voxelsPtr,
             inout Voxel v)
{
    const uint oct = getOctet_1_1(upos);

    v.size  = 1;
    v.value = GETBYTE(voxelsIn, voxelsPtr+oct);
}
/**
 *  Return true if we are inside an air voxel of some size.
 *  Voxel is set accordingly.
 */
bool getAirVoxel(
    const Position pos,
    inout Voxel voxel,
    const float distance,
    const uint cache[2])
{
/*
    voxelsIn[voxelsRoot/4 + 0] = flags
    voxelsIn[voxelsRoot/4 + 1] = twigsOffset;
    voxelsIn[voxelsRoot/4 + 2] = l2TwigsOffset;
    voxelsIn[voxelsRoot/4 + 3] = leavesOffset;
    voxelsIn[voxelsRoot/4 + 4] = l2IndexOffset;
    voxelsIn[voxelsRoot/4 + 5] = leafIndexOffset;
    voxelsIn[voxelsRoot/4 + 6] = (leafEncodeBits | (l2EncodeBits<<8));
*/
    const uint voxelsRoot  = cache[0];
    const uint offsets     = cache[1];

    #define l2twigsOffset    voxelsRoot + voxelsIn[offsets+2]
    #define leavesOffset     voxelsRoot + voxelsIn[offsets+3]
    #define l2IndexOffset    voxelsRoot + voxelsIn[offsets+4]
    #define leafIndexOffset  voxelsRoot + voxelsIn[offsets+5]

    #define GETTWIGSOFFSET (voxelsRoot + voxelsIn[offsets+1])
    #define GETBITCOUNTS (voxelsIn[offsets+6])

    const uvec3 upos       = pos.upos;
    const uint twigsOffset = GETTWIGSOFFSET;
    uint voxelsPtr         = voxelsRoot;

    if(isSolidRoot(upos, twigsOffset, voxelsPtr, voxel)) return voxel.value==0;

    #if CHUNK_SIZE_SHR-OCTREE_ROOT_BITS>6
    if(isSolidBranch(distance, upos, twigsOffset, voxelsPtr, voxel, 64)) return voxel.value==0;
    #endif

    #if CHUNK_SIZE_SHR-OCTREE_ROOT_BITS>5
    if(isSolidBranch(distance, upos, twigsOffset, voxelsPtr, voxel, 32)) return voxel.value==0;
    #endif

    if(isSolidBranch(distance, upos, twigsOffset, voxelsPtr, voxel, 16)) return voxel.value==0;

    if(isSolidBranch(distance, upos, twigsOffset, voxelsPtr, voxel, 8)) return voxel.value==0;

    const uint bitCounts = GETBITCOUNTS;

    if(isSolidBranchLevel3(
        distance,
        upos,
        bitCounts,
        l2IndexOffset,
        l2twigsOffset,
        voxelsPtr,
        voxel)) return voxel.value==0;

    if(isSolidBranchLevel2(
        distance,
        upos,
        bitCounts,
        leafIndexOffset,
        leavesOffset,
        voxelsPtr,
        voxel)) return voxel.value==0;

    gavLeaf(upos, voxelsPtr, voxel);

    return voxel.value==0;
}

