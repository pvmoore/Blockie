#version 430 core
layout(local_size_x = 8, local_size_y = 8) in;

//layout(binding = 0, std430) readonly buffer I0 {
//    // 1 position = 3 floats
//	float positionsIn[];
//};
//layout(binding = 1, std430) readonly buffer I1 {
//    // 1 voxel = 1 uint
//	uint voxelsIn[];
//};
// vec4(vec3 pos, float voxel)
layout(binding = 0, rgba32f)
uniform readonly image2D imageIn;

layout(binding = 1, rgba8)
uniform writeonly image2D imageOut;

//layout(binding = 2, rgba8)
//uniform readonly image2D material0;

layout(binding=3)
uniform sampler2D SAMPLER0;


uniform ivec2 SIZE;
uniform vec3 SUN_POS;
uniform vec3 CAMERA_ORIGIN;

ivec2 g_pos  = ivec2(gl_GlobalInvocationID.xy);
ivec2 l_pos  = ivec2(gl_LocalInvocationID.xy);
uint g_index = gl_GlobalInvocationID.x +
               gl_GlobalInvocationID.y*SIZE.x;
uint l_index = gl_LocalInvocationIndex;

#include "useful_functions.comp"
#include "header.comp"
#include "voxel.comp"
//#include "perlin_noise.comp"
#include "simplex_noise_3d.comp"

#line 1
/**
 *   0
 * 3 . 1
 *   2
 */
vec3 calculateNormal() {
    ivec2 i = g_pos;
    const ivec2 U  = i+ivec2(0,-1);
    const ivec2 L  = i+ivec2(-1,0);
    const ivec2 P  = i;
    const ivec2 R  = i+ivec2(1,0);
    const ivec2 D  = i+ivec2(0,1);

    const vec3 up    = imageLoad(imageIn, U).xyz;
    const vec3 left  = imageLoad(imageIn, L).xyz;
    const vec3 pos   = imageLoad(imageIn, P).xyz;
    const vec3 right = imageLoad(imageIn, R).xyz;
    const vec3 down  = imageLoad(imageIn, D).xyz;

    const vec3 n1 = cross(up-pos, left-pos);
    const vec3 n2 = cross(down-pos, right-pos);

    return normalize(n1+n2);
}
float getBrightness(const vec3 hitPos, const vec3 normal) {
    const vec3 lightPos = SUN_POS;
    const vec3 toLight  = normalize(lightPos-hitPos);
    const float NdotL      = dot(normal, toLight);
    return max(NdotL, 0);
}
vec3 getDiffuseColour(const uint voxel) {
    return getDiffuse(voxel);
}
//vec4 getDiffuseColour(const vec3 hitPos, const uint voxel) {
//    const vec3 lightPos = SUN_POS;
//    const vec3 normal   = calculateNormal();
//    const vec3 toLight  = normalize(lightPos-hitPos);
//
//    const float NdotL      = dot(normal, toLight);
//    const float brightness = max(NdotL, 0);
//
//    vec3 pixel = getDiffuse(voxel);
//
//    return vec4((pixel*0.70f) + (pixel*0.30f * brightness), 1);
//}
vec3 applyFog(vec3  rgb,      // original color of the pixel
              float distance) // camera to point distance
{
    const float density = 0.00015;
    const float fogAmount = 1.0 - exp( -distance*density );
    const vec3  fogColor  = vec3(0.5,0.6,0.7);
    return mix(rgb, fogColor, fogAmount);
}
vec3 applyFogWithSunScattering(
    vec3  rgb,      // original color of the pixel
    float distance, // camera to point distance
    vec3  rayDir,   // camera to point vector
    vec3  sunDir)   // sun light direction
{
    const float density = 0.00015;
    float fogAmount = 1.0 - exp( -distance*density );
    float sunAmount = max( dot( rayDir, sunDir ), 0.0);
    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish
                           vec3(1.0,0.9,0.7), // yellowish
                           pow(sunAmount,8.0) );
    return mix( rgb, fogColor, fogAmount );
}
vec3 applyGroundFog(
    vec3  rgb,      // original color of the pixel
    float distance, // camera to point distance
    vec3  rayOri,   // camera position
    vec3  rayDir)   // camera to point vector
{
    const float b = 0.0001;
    const float c = 1;
    const float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;
    const vec3  fogColor  = vec3(0.5,0.6,0.7);
    return mix( rgb, fogColor, fogAmount );
}
void main() {
    vec4 data   = imageLoad(imageIn, g_pos);
    uint voxel  = uint(data.w);
    if(voxel==0) {
        imageStore(imageOut, g_pos, vec4(0,0,0,0));
        return;
    }
    vec3 hitPos = data.xyz;
    vec3 normal = calculateNormal();
    float dist  = voxel == 0 ? MAX_DISTANCE : distance(CAMERA_ORIGIN, hitPos);

    vec3 diffuse = getDiffuseColour(voxel);

    if(voxel==V_ROCK1 || voxel==V_GRASS1 || voxel==V_EARTH1) {
        vec4 t  = texture(SAMPLER0, (hitPos.xz+hitPos.y)/100);
        diffuse.xyz = diffuse.xyz*0.25 + t.xyz;
    }

    // diffuse lighting
    diffuse = mix(diffuse*0.25, diffuse, getBrightness(hitPos, normal));

    // noise
    diffuse += clamp(40/(dist+0.1), 0, 0.2)*snoise(hitPos*5);

    #define FOG 1
    #if FOG
    vec3 rayDir = normalize(hitPos-CAMERA_ORIGIN);
    vec3 sunDir = normalize(SUN_POS-CAMERA_ORIGIN);
    //const vec4 colour = vec4(applyFog(diffuse.rgb, dist), diffuse.a);
    //const vec4 colour = vec4(applyFogWithSunScattering(diffuse.rgb, dist, rayDir, sunDir), diffuse.a);
    const vec4 colour = vec4(applyGroundFog(diffuse.rgb, dist, CAMERA_ORIGIN, rayDir), 1);
    #else
    // blend diffuse and sky based on distance from camera
    float fade = clamp(exp(8*(dist/15000)) / 120, 0.0, 1.0);
    vec3 sky   = vec3(0.345098,0.466667,0.560784);
    const vec4 colour = vec4(mix(diffuse.rgb, sky, fade), 1);
    #endif

    imageStore(imageOut, g_pos, colour);
}
