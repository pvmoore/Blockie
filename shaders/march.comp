#version 430 core
#define GROUP_SIZE_X 8
#define GROUP_SIZE_Y 8
layout(local_size_x = GROUP_SIZE_X, local_size_y = GROUP_SIZE_Y) in;

layout(binding = 0, std430) readonly buffer I0 {
    // voxel data in ubytes
	uint voxelsIn[];
};
layout(binding = 1, std430) readonly buffer I1 {
    // chunk data in uints
	uint chunkDataIn[];
};
layout(binding = 2, rgba32f)
uniform writeonly image2D imageOut;

//layout(binding = 3, std430) writeonly buffer O0 {
//	float debugOut[];
//};

uniform ivec2 SIZE;
uniform uvec3 WORLD_CHUNKS_XYZ;
uniform vec3  WORLD_BB[2];
uniform vec3  CAMERA_ORIGIN;
uniform vec3  SCREEN_MIDDLE;
uniform vec3  SCREEN_XDELTA;
uniform vec3  SCREEN_YDELTA;

ivec2 g_pos  = ivec2(gl_GlobalInvocationID.xy);
ivec2 l_pos  = ivec2(gl_LocalInvocationID.xy);
uint g_index = gl_GlobalInvocationID.x +
               gl_GlobalInvocationID.y*SIZE.x;
uint l_index = gl_LocalInvocationIndex;

#include "useful_functions.comp"
#include "header.comp"
#include "getoctet.comp"
#include "chunk.comp"

#line 1

bool updatePosition(inout Position pos, vec3 add) {
    pos.fpos += add;
    pos.upos  = ivec3(floor(pos.fpos-WORLD_BB[0]));

    uvec3 xyz = pos.upos >> CHUNK_SIZE_SHR;

	bool outOfBounds = any(greaterThanEqual(xyz, WORLD_CHUNKS_XYZ));

    const uint chunksX  = WORLD_CHUNKS_XYZ.x;
	const uint chunksXY = WORLD_CHUNKS_XYZ.x*
	                      WORLD_CHUNKS_XYZ.y;

    const int prevChunk = pos.chunk;
    pos.chunk = outOfBounds ? -1
                : int(xyz.x +
                      xyz.y*chunksX +
                      xyz.z*chunksXY);
    return pos.chunk != prevChunk;
}
bool isAirChunk(const uint flags) {
    return (flags & 0xffu)==1;
}
vec3 airChunkDistanceField(const uint flags) {
    return unpackUnorm4x8(flags).yzw * 255;
}
vec3 airNibbleDistanceField(const uint v) {
    return vec3(v & 31u, (v>>5) & 31u, (v>>10) & 31u);
}
float getMinDistToEdge(
    const Ray ray,
    const Position pos,
    const uint voxelSize)
{
    const vec3 p    = pos.fpos-WORLD_BB[0];
    const vec3 rem  = mod(p, voxelSize);
    const vec3 size = vec3(greaterThanEqual(ray.direction, vec3(0))) * voxelSize;
    const vec3 dist = size-rem;

    const vec3 m    = dist * ray.invDirection;
    const float res = min(m.x, min(m.y, m.z));
    return max(res, 0);
}
float getMinDistToEdgeOfDistanceField(
    const Ray ray,
    const Position pos,
    const vec3 radius,
    const uint sideSize)    // CHUNK_SIZE or NIBBLE_SIZE
{
    // radius = 0 = 1 air chunk  (r=0,    r2=0)
    //        = 1 = 3 air chunks (r=512,  r2=1024)
    //        = 2 = 5 air chunks (r=1024, r2 = 2048)
    //          etc...
    const vec3 r    = radius*sideSize;
    const vec3 r2   = r*2;
    const vec3 p    = pos.fpos-WORLD_BB[0];
    const vec3 rem  = mod(p, sideSize) + r;
    const vec3 size = vec3(greaterThanEqual(ray.direction, vec3(0))) * (sideSize+r2);
    const vec3 dist = size-rem;

    const vec3 m    = dist * ray.invDirection;
    const float res = min(m.x, min(m.y, m.z));
    return max(res, 0);
}
/**
 *  Skip dist a little bit depending on how near to the camera
 *  the ray is. This is necessary in the pathological case
 *  where the ray is parallel to and on the edge of a voxel box.
 *  Also, a small bump greatly improves speed without compromising
 *  quality. Adjust these values appropriately depending on scene.
 */
void skipLOD(const float distance, inout float dist) {
    const float bump = (distance+0.0001)/1000;

    // handle pathological case
    if(dist<0.0001) {
        dist += clamp(bump, 0.005, 0.5);
    }
    // skip a bit based on distance to camera
    dist += clamp(bump, 0.0001, 15);
}
Voxel march(const Ray ray,
            inout Position pos,
            const float maxDistance)
{
    Voxel voxel;
    float distance   = 0;
    uint voxelsRoot  = chunkDataIn[pos.chunk];
    uint offsets     = voxelsRoot/4;
    uint flags       = voxelsIn[offsets];
    uint cache[2]    = uint[](
        voxelsRoot,
        offsets
    );

    // Assume:
    //      1) pos.chunk will always start with a valid chunk
    //      2) distance will always start < maxDistance

    do{
        float dist;

        if(isAirChunk(flags)) {
            dist = getMinDistToEdgeOfDistanceField(ray, pos, airChunkDistanceField(flags), CHUNK_SIZE);
        } else {

            if(!getAirVoxel(pos, voxel, distance, cache)) break;

            const bool isRoot = (voxel.size == NIBBLE_SIZE);

            if(isRoot) {
                uint dfield = GETUSHORT(voxelsIn, ((voxelsRoot+DFIELD_OFFSET)>>1) + voxel.oct);
                dist = getMinDistToEdgeOfDistanceField(ray, pos, airNibbleDistanceField(dfield), NIBBLE_SIZE);
            } else {
                dist = getMinDistToEdge(ray, pos, voxel.size);
            }
        }

        skipLOD(distance, dist);

        distance += dist;

        bool chunkChanged = updatePosition(pos, ray.direction*dist);

        if(chunkChanged) {
            if(pos.chunk==-1) break;
            voxelsRoot  = chunkDataIn[pos.chunk];
            offsets     = voxelsRoot/4;
            flags       = voxelsIn[offsets];
            cache[0] = voxelsRoot;
            cache[1] = offsets;
        }
	}while(distance<maxDistance);
	return voxel;
}

Ray generateRay() {
    vec3 middle = SCREEN_MIDDLE;
    vec3 xDelta = SCREEN_XDELTA;
    vec3 yDelta = SCREEN_YDELTA;
    vec2 mid    = vec2(g_pos) - vec2(SIZE)/2.0f;

    Ray ray;
    ray.start        = CAMERA_ORIGIN;
    ray.direction    = normalize((middle + mid.x*xDelta) + mid.y*yDelta);
    ray.invDirection = 1.0f/ray.direction;
    return ray;
}

void main() {
    const Ray ray = generateRay();

    Position pos = Position(uvec3(0), ray.start, -1);
    updatePosition(pos, vec3(0));

    Voxel voxel = march(ray, pos, MAX_DISTANCE);

    imageStore(imageOut, g_pos, vec4(pos.fpos, voxel.value));
}
